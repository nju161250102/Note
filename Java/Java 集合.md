# Java 集合

### 1. 概述

| 集合          | 数据结构        | 是否有序 | 备注     |
| ------------- | --------------- | -------- | -------- |
| ArrayList     | 数组            | 随机读取 |          |
| LinkedList    | 双向链表        | 顺序读取 |          |
| Vector        | 数组            | 随机读取 | 线程安全 |
| AarryDeque    | 循环数组        | 是       |          |
| PriorityQueue | 双向链表        | 是       |          |
| TreeSet       | 红黑树          | 是       |          |
| HashSet       | 哈希表          | 否       |          |
| LinkedHashSet | 哈希表+双向链表 | 是       |          |
| TreeMap       | 红黑树          | 是       |          |
| HashMap       | 哈希表          | 否       |          |
| HashTable     | 哈希表          | 否       | 线程安全 |
| LinkedHashMap | 哈希表+双向链表 | 是       |          |

### 2. ArrayList

- 容量（capacity），表示底层数组的实际大小，默认值为10
- ArrayList没有实现同步，如果需要并发访问，使用 synchronized 加锁，或者使用 Vector 替代
- modCount 用来记录 ArrayList 结构发生变化的次数。在进行序列化或者迭代等操作的前后进行比较，如果变化则抛出异常
- 序列化时控制只序列化数组中有元素填充那部分内容

#### 扩容

在添加元素之前检查剩余空间，如果需要则通过 grow 方法扩容。新容量大小为`oldCapacity + (oldCapacity >> 1)`，即旧容量的1.5倍。扩容操作需要调用 `Arrays.copyOf()` 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

#### 删除

将删除点之后的元素向前移动一个位置，时间复杂度为 O(N)，代价高昂。最后显式的为最后一个位置赋`null`值。

### 3. LinkedList

- 通过双向链表实现，每个节点用内部类 Node 实现
- 可以看做顺序容器、栈、队列

#### 增加元素

默认在链表末尾增加，否则需要先通过线性查找找到具体位置，再修改引用添加元素。具体朝那个方向找取决于条件`index < (size >> 1)`，即index靠近前端还是后端。

#### 删除元素

都需要线性时间查找位置，需要考虑删除元素是第一个或者最后一个时的边界情况。

### 4. Vector

- 与 ArrayList 类似，但是使用了 synchronized 进行同步，因此开销更大，速度更慢。
- 可以使用 `Collections.synchronizedList();` 得到一个线程安全的 ArrayList。
- 每次扩容是旧容量的两倍

### 5. AarryDeque

- 实现了Deque的接口，在两端添加、删除、查找
- 非线程安全，不允许放入null元素
- 插入时的下标越界处理：`head = (head - 1) & (elements.length - 1)`起到取模的作用
- 扩容函数：申请更大的数组（2倍），将head两侧的元素分别复制进新数组。在插入元素时扩容

### 6. PriorityQueue

保证每次取出的元素都是权值最小的，可以根据自然顺序，也可以根据Comparator比较器实现。实现了Queue接口，不能放入null元素，使用数组实现的小顶堆。

- 插入：容量不足时扩容，插入后调整数组维持堆的特性
- 调整：从指定位置开始与父节点比较并交换，是一个向上冒泡的过程
- 取出：数组的第一个元素
- 删除：记录最小的元素，用最后一个元素替换，然后与左右子节点较小的那个交换，除非小于或等于左右节点中的任一个。

### 7. HashMap & HashSet

底层是一个Entry 类型的数组。Entry 存储着哈希值、键、值和链表下一个Entry节点。一个桶存储的链表长度大于 8 时会将链表转换为红黑树。hashCode() 方法决定了会放在哪个桶内。

- 冲突解决：拉链法，链表插入使用头插法，根据equals()方法判断是否相等
- 插入null值：指定使用序号为0处存放
- 确定桶下标：计算哈希值，取模确定存放位置

#### 扩容

设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。

为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大。table 的容量大小保证为2的n次方。

- 将 capacity 设为原来的两倍
- 把原来的键值对重新插入新的数组中（重新计算桶下标时位运算判断是否需要增加）

将传入的容量转换为 2 的 n 次方:

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

#### HashSet

是对HashMap的简单包装，只使用键，值全是Object对象

### 8. LinkedHashMap & LinkedHashSet

内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序（访问顺序）（根据变量 accessOrder 判断）。迭代遍历时不需要遍历全部的数组。

当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。从而保证保证链表尾部是最近访问的节点，而链表首部就是最近最久未使用的节点。

#### LRU缓存

- 设定最大缓存空间 MAX_ENTRIES  为 3；
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；
- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

### 9. TreeSet & TreeMap

按照Key的大小顺序对Map中的元素进行排序，底层通过红黑树排序。

红黑树是满足如下条件的二叉查找树（binary search tree）：

1. 每个节点要么是红色，要么是黑色。
2. 根节点必须是黑色
3. 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。
4. 对于每个节点，从该点至`null`（树尾端）的任何路径，都含有相同个数的黑色节点。

#### 寻找节点后继

对于一棵二叉查找树，给定节点t，其后继（树中比大于t的最小的那个元素）可以通过如下方式找到：

1. t的右子树不空，则t的后继是其右子树中最小的那个元素。
2. t的右孩子为空，则t的后继是其第一个向左走的祖先。

#### 删除

1. 删除点p的左右子树都为空，或者只有一棵子树非空。
2. 删除点p的左右子树都非空：用p的后继s代替p，然后使用情况1删除s

### 10. WeakHashMap

适用于缓存场景，*WeakHashMap* 内部是通过弱引用来管理`entry`的，弱引用的特性对应到  WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。