# 嵌入式系统概论

## 1 嵌入式系统概述
### 1.1 嵌入式系统的定义  
* IEEE（国际电气和电子工程师协会）的定义：  
  **嵌入式系统是用于控制、监视或者辅助操作机器和设备的装置 ** 

* 普遍被认同的定义：

  **嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。**

* 其他定义
    * 包含有计算机，但又不是通用计算机的计算机应用系统
    * 看不见的计算机，一般不能被用户编程, 它有⼀些专用的I/O设备, 对用户的接口是应用专用的

* 嵌入式系统三要素：
    * 嵌入性：嵌入到对象体系中，有对象环境要求
    * 专用性：软、硬件按对象要求设计、裁减
    * 计算机：实现对象的智能化功能

### 1.2 嵌入式系统的组成
* 硬件：微处理器为核心集成存储器和系统专用的输入/输出设备  
* 软件：初始化代码及驱动、嵌入式操作系统和应用程序等，有机地结合形成系统特定的一体化软件  

### 1.3 嵌入式系统的特点
* 形式多样、面向特定应用
* 处理器和处理器体系结构类型多
* 关注成本
* 实时性和可靠性的要求
* 适应多种处理器、可剪裁、轻量型、实时可靠、可固化的嵌入式操作系统
* 开发需要专门工具和特殊方法

### 1.4 嵌入式系统的分类
* 按嵌入式处理器的位数来分类
* 按应用来分类
* 按速度分类
* 按确定性来分类
* 按嵌入式系统软件复杂程度来分类

### 1.5 嵌入式系统安全
数据存储不安全、服务端控制措施部署不当、传输过程中没有加密、身份认证措施不当、密钥保护措施不当、会话处理不当、敏感数据泄漏

### 1.6 嵌入式系统的典型应用
工控设备、信息家电、无人驾驶、VR、智能家居、无人机

## 3 嵌入式系统设计
### 软硬件分工
软件部分：操作系统功能（任务调度、资源管理、设备驱动）、协议栈、应用程序框架。

双重性部分：算法、数学运算

硬软件设计的趋势——融合、渗透，对系统设计的影响——协同设计

## 4 4.	嵌入式硬件系统
### 4.1 嵌入式微处理器基础
#### 冯诺伊曼结构与哈佛结构
* 冯诺伊曼结构：以运算单元为中心；采用存储程序原理；存储器是按地址访问、线性编址的空间；控制流由指令流产生；指令由操作码和地址码组成；数据以二进制编码
* 哈佛结构：将程序和数据存储在不同的存储空间中，允许在一个机器周期内同时获得指令字和操作数，从而提高了执行速度

#### CISC与RISC
* CISC复杂指令集：每个指令可执行若干低级操作，每条指令子长不等，复杂的寻址模式
* RISC精简指令集：统一指令编码，泛用的寄存器，单纯的寻址模式，支持少数数据类型

#### 流水线技术
读取指令、指令解码与读寄存器、执行、存储器访问、写寄存器

#### 信息存储的字节顺序
* 小端就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
* 大端就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

#### ARM架构


### 4.2 嵌入式系统的存储体系
#### 存储器组织
地址线、数据线、读写信号

#### RAM随机存储器
读写方便快捷，使用电信号完成读写操作；必须有直流电源供电，断电数据丢失。

* DRAM动态随机存储器：周期性刷新
* SRAM静态随机存储器：不用刷新，更快，密度更低

#### ROM只读存储器
数据不能改变，只能读取，ROM在工厂中被写入程序

#### Flash快闪存储器
非易失性存储器，随机读取，写入远比读取慢，块级操作

* NOR
* NAND

#### 存储器结构
* Flat single-space
* Segmented
* Bank-switched
* Multiple-space
* Virtual

## 5 嵌入式软件系统
### 嵌入式软件与桌面软件的对比
内存、CPU能力、操作系统、实时行为、开发流程、执行流程、工具组件、开发工具。

### 嵌入式软件如何影响硬件设计
#### 软件/硬件权衡
* 微处理器选择：对效率的影响
* 内存大小和组合
* ROM/RAM互相交换数据能力

#### 硬件调试
* 仿真器：使用不广泛
* 监视调试器：需要通讯通道和ROM/RAM交换能力
* 片上调试：需要板载连接器和ROM/RAM交换能力

#### 支持自检
* I/O电路：循环反馈
* 板载开关：用于配置和模式选择
* 状态显示：字符或者只是LED（三种状态：开，关，闪烁）

### 嵌入式软件架构
#### 嵌入式软件体系结构
* **驱动层**：板级初始化程序、与系统软件相关的驱动、与应用软件相关的驱动、与应用软件相关的驱动不一定需要与操作系统连接，这些驱动的设计和开发由应用决定。
* **操作系统层**：操作系统层包括嵌入式内核、嵌入式TCP/IP网络系统、嵌入式文件系统、嵌入式GUI系统和电源管理等部分。
* **中间件层**：主要包括嵌入式CORBA、嵌入式Java、嵌入式DCOM和面向应用领域的中间件软件。
* **应用层**：应用层软件主要由多个相对独立的应用任务组成。每个应用任务完成特定的工作，如I/O任务、计算的任务、通信任务等，由操作系统调度各个任务的运行

#### 为实时系统建立模型
* 单线程程序模型：快速简单、易修改 | 应用领域受限、安全性、不易移植
* 多线程程序模型：任务划分独立、并行、高吞吐量 | 资源竞争

#### 嵌入式软件体系结构概述
* 轮询：
  * 反复按顺序询问设备是否执行任务（高优先级任务可以增加询问次数）
* 状态机
  * 循环中根据状态决定需要执行的操作
  * 和轮询方式类似，但是只有当前状态被执行。每个状态决定了下一状态
* 带中断的轮询
  * 通过状态标记跳出循环执行任务
* 只有中断
  * 太多的ISR引发问题
  * 需要处理嵌套中断，否则时间长且优先级低的中断将被忽略
* 功能队列调度
  * 函数指针被添加至队列，由任务或中断添加
  * 主循环遍历队列并执行
* 实时操作系统

|架构|优先级|反应时间|变更的影响|易用性|
|:---|:---|:---|:---|:---|
|轮询|无（顺序执行）|所有任务总和|影响其他任务的执行时间|无数据共享问题|
|状态机|每个状态决定下个状态的优先度|所有任务总和|影响其他任务的执行时间|无数据共享问题|
|带中断的轮询|中断的优先级高于主循环|所有任务总和或者中断执行时间|对中断服务影响很小，其余相同|处理中断中的数据共享问题|
|仅中断|取决于中断的优先级|中断执行时间|几乎没有影响|处理中断中的数据共享问题|
|功能队列调度|中断具有优先级，任务执行无|最长任务的执行时间|很小|处理中断中的数据共享问题|

#### 实时操作系统
特征：可靠性、可预测性、性能、紧凑、可扩展性。实时操作系统中没有主循环，由调度程序决定应该运行哪一个任务。

* 就绪时间：进程准备就绪的时间
* 截止时间：进程必须完成的时间
  * 硬截止：如果错过系统出错
  * 软截止：用户可能会注意到，但是不会出错
* 发生周期：进程激活的间隔
* CPU利用率：正在做有效工作的CPU时间占比，假设没有调度开销
* 进程的三态
* 多任务操作系统、线程、任务控制块TCB

#### 线程调度
* 如何决定执行哪个线程：
  * 抢占式与非抢先式调度
  * 定期与非周期性任务
  * 固定优先级与动态优先级
  * 优先级倒置异常
  * 其他调度异常
* 如何评估调度策略：
  * 能够满足所有对时间的要求
  * CPU利用率
  * 调度开销
  * 延迟
  * 总完成时间 
* RMS调度（单调速率调度）：根据执行周期的长短来决定调度优先级
* EDF调度（最早截止时间调度）：根据任务的截止时间动态分配优先级
* 比较：RMS调度更简单，EDF可以实现CPU的完全利用

## 6 嵌入式实时内核
### 6.1 实时任务调度（任务管理）
* μC/ OS-II最多可以管理64个任务
* μC/ OS-II保留了四个最高优先级的任务和四个最低优先级的任务供自己使用。最多可以完成56个应用程序任务。
* 优先级值越低，优先级越高。在当前版本的μC/ OS-II中，任务优先级编号
也用作任务标识符

* 空闲任务OSTaskIdle()
* 统计任务OSTaskStat()
* 任务控制块OS_TCB：描述一个任务的核心数据结构，存放了它的各种管理信息，包括任务堆栈指针，任务的状态、优先级，任务链表指针等
* 单向空闲链表OSTCBFreeList，双向使用链表OSTCBList
* 任务就绪表OSRdyGrp OSRdyTbl[]

### 6.2 中断与时钟（时钟管理）
中断服务程序ISR：
* 保存全部CPU寄存器的值
* 调用OSIntEnter()或者全局变量OSIntNesting+1
* 执行用户代码做中断服务
* 调用OSIntExit()
* 恢复使用CPU寄存器
* 执行中断返回指令

时钟节拍OSTickISR：特殊的中断，来自专门的硬件定时器或者交流电源的信号。
* 保存CPU寄存器的值
* 调用OSIntEnter()或者全局变量OSIntNesting+1
* 调用OSTimeTick()检查每个任务的时间延时
* 调用OSIntExit()
* 恢复使用CPU寄存器
* 执行中断返回指令

时间管理相关系统服务：
* OSTimeDLY() 任务延时函数
* OSTimeDLYHMSM() 按时分秒的任务延时函数
* OSTimeDLyResume() 延时的任务提前结束进入就绪态
* OSTimeGet() 获得该计数器的当前值
* OSTimeSet() 设置该计数器的值

### 6.3 任务之间的通信与同步
事件控制块ECB：所有的通信信号被看作事件。

OS_Event: OSEventType, OSEventCnt, OSEventPtr, OSEventGrp

同步与互斥：关闭OS_ENTER_CRITICAL()/打开OS_EXIT_CRITICAL()中断的方式处理临界区代码

信号量：共享资源的互斥访问；任务之间的行为同步。OS_CFG.H中将OS_SEM_EN开关常量置为1
* OSSemCreate() 创建信号量
* OSSemPend() 等待信号量P
* OSSemPost() 发送信号量V
* OSSemAccept() 无条件等待
* OSSemQuery() 查询信号量当前状态

其他：消息邮箱、消息队列、

### 6.4 存储管理
实模式存储管理，不划分内核空间和用户空间，直接访问物理内存空间。只有运行上下文和栈是独享的，其他资源都是共享的。内存布局：代码段(text)、数据段(data)、bss段、堆空间、栈空间。

固定分区的存储管理方法。每个分区包含有整数个大小相同的块。应用程序就可以从不同的内存分区中得到不同大小的内存块。使用内存控制块MCB跟踪每一个内存分区。

## 7 板级支持包与系统引导
### 嵌入式软件运行流程
* 上电复位
* 板级初始化：汇编语言实现，初始化堆栈指针寄存器、BSS段、CPU芯片级
* 引导/升级系统：根据需要进入不同阶段
* 系统初始化：初始化数据空间、接口外设、文件网络系统、中间件
* 应用初始化：信号量、消息队列
* 多任务应用：按照已确定的算法进行调度

### BSP 板级支持包
提供一段启动代码（类似BIOS，但功能区别很大），位于RTOS靠近传统硬件的部分。BSP中的驱动程序抽象物理设备或虚拟设备的功能软件，用于管理这些设备的操作。

BSP和BIOS/UEFI的区别：BIOS主要是负责在电脑开启时检测、初始化系统设备、装入操作系统并调度操作系统向硬件发出的指令。BSP和操作系统绑在⼀一起运行，还包含和系统相关的基本驱动。BIOS用户不能更改，只能对参数进行修改设置，BSP可以编程修改，添加和系统无关的驱动和程序。

BSP的特点和功能：硬件相关性、操作系统相关性。

### 嵌入式系统的初始化过程
* 片级初始化：CPU的初始化，从上电的初始状态逐步设置为系统要求的工作状态
* 板级初始化：CPU以外其他硬件设备的初始化，设置某些软件的数据结构和参数
* 系统级初始化：软件初始化为主，将操作权交给系统完成余下的初始化

### BootLoader
嵌入式系统中的OS启动加载程序，包括固件中的boot代码和Boot Loader两部分

嵌入式系统中引导加载程序：  
* 没有BIOS那样的固件程序
* 系统的加载启动任务完全由Boot Loader来执行
* 存储位置
* 复制过程

#### Boot Loader的生命周期
* 初始化硬件，如设置UART(至少设置一个)，检测存储器等
* 设置启动参数，告诉内核硬件的信息，如用哪个启动界面，波特率
* 跳转到操作系统的首地址
* 消亡

#### Boot Loader的操作模式
* 启动加载模式
* 下载模式

#### Boot Loader的调试
* 硬件调试
* 源码软件调试

## 8 模型