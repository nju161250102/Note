# 数据库开发技术

## Chapter0 前言
### 数据库基础知识
* 关系代数
* DB、DBMS基于数据库应用程序
* 数据库发基本特性
* SQL（基本DDL、DML、触发器、存储过程、语法、用法）

### 开发成功数据库应用的要点
* 理解数据库体系结构
* 理解锁和并发控制特性（每个数据库以不同的方式实现）
* 不要把数据库当作“黑盒”
* 性能、安全性都是适当的被设计出来的
* 用尽可能简单的方法解决问题
* DBA和RD之间的关系


## Chapter1 为性能而设计
应用系统的首要目标：满足业务需求  
实际的情况是：  
* 处于技术挑战的刺激之下
* 忽视目标
* 重视手段
* 忽视数据的质量
* 重视按期交付功能
强调良好的模型和合理的数据库设计是任何信息系统的基础  

### 数据的关系视图
* 关系模型中关系的含义
* 关系模型的一致性：  
只要遵守关系理论，可以保证基于数据库的任何查询结果与原始数据具有同样的有效性。关系理论包括：关系不包含重复数据；记录之间没有顺序。查询效率与更新效率不能同时提高。（要有选择地进行优化）

### 规范化
* 1NF确保原子性（原子性的力度和价值）
* 2NF检查对键的完全依赖（控制数据冗余和查询性能）
* 3NF检查属性的独立性  

规范化的价值：
* 合理规范化的模型可应对需求变更
* 规范化数据重复降至最少

### 有值，无值、空值
* 表中每一条记录都应该是事物的状态描述，如果大部分信息都显示“不知道”，无疑大大降低了信息可信性。
* 存在空值意味着关系模型存在严重的问题。
* 空值对程序逻辑是危险的，必须使用的话一定要清楚在特定情况下的影响。

### 限用Boolean字段
SQL中不存在Boolean类型。通过实现flag表示标志位的Y/N或T/F，但是往往会增加信息字段包含更多的信息。更不要通过数字来表示所有的状态组合。  
```
数据库一开始要尽量直观，不要引入巧妙的设计。数据存储领域中，往往是用空间换时间，不需要巧妙地减少空间占用.
```

### 理解子类型（SubType）
* 表中有太多属性的另一个原因，是对数据项之间的关系了解不够深入。
* 一般情况下，给子类型表指定完全独立于父表主键的主键是极其错误的。
```
完备型的分类方式可以通过遍历查询来完成。不完备的分类方式下，通过一张对应表存放父表记录对应的类型表名。
```

### 约束应明确说明
* 数据库中隐含约束是一种不良设计（约束应当明确）
* 字段的性质随着环境变化而变化时设计的错误和不稳定性
* 数据语义属于DBMS，不能放到应用程序中（数据库中找脏数据是极其困难的）

### 如何处理历史数据
定义有效时间、定义终止时间、保持价格生效时间……  

### 设计与性能
调优（tuning）在目前情况下性能优化至最佳  
性能拙劣的罪魁祸首是错误的设计  

### 处理流程
* 异步模式处理（批处理）
* 同步模式处理（实时交易）  
处理数据的方式会影响我们物理结构的设计  

### 数据集中化（Centralizing）
分布式数据系统的复杂性大大增加：远程数据的透明引用访问代价很高，不同数据源数据结合极为困难。离数据越近，访问速度越快。 
```
选择分布式系统的原因：分布式数据库的吞吐量大。单条查询速度慢，但是大量查询的速度更快，更有利于大规模访问。
```

## Chapter2 高效访问数据库
开发环境比生产环境简单得多。开发者常常忽略从大局上把握整个架构和设计。
```
硬盘读写以块为单位
```

## 期末复习
### 1 DBMS相关问题
#### DBMS的执行过程
* 语法分析：分析语句语法是否符合规范、衡量表达式意义
* 语义分析：检查语句中的数据库对象是否存在并且用户具有相应的权限
* 视图转换：涉及视图的查询转换为对基表的查询
* 表达式转换：复杂的SQL表达式转为较简单的等效连接
* 选择优化器
* 选择连接方式表
* 选择连接顺序
* 选择对数据的搜索路径
* 运行执行计划

#### 语义分析的硬解析和软解析
硬解析：在共享池中没有找到已有的执行计划（对sql代码文本进行哈希判断），则使用优化器对sql语句进行优化，转化为一些等价语句，并选择代价最小的语句生成执行计划。

软解析：共享池中已经存在对应的执行计划，直接使用。

不能使用软解析的情形：不完全相同的语句，不完全相同的对象和schema。硬解析需要CPU生成执行计划并使得闩的排队频繁。

#### MySQL三层逻辑架构
* 连接管理、授权认证、安全：每个连接对应一个线程，通过用户名/密码或者SSL证书进行认证和权限检查
* 解析查询、优化：调整顺序、选择合适的索引、检查缓存
* 存储引擎：存取数据、开启事务

### 2 索引相关问题
#### 2.1 B树索引
B树结构

适用范围：
* 全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值
* 精确匹配某一列并范围匹配另一列

使用限制：
* 不能从索引的最左列开始查找
* 不能跳过索引中的列
* 范围查询右侧的所有列均无法使用索引

#### 2.2 哈希索引
适用范围：
* 特定场合
* 数据仓库的星型schema
* InnoDB引擎的自适应哈希索引

使用限制：
* 只包含哈希值和行指针，不存储字段值
* 无法按索引值排序
* 不支持部分索引列匹配查找
* 只能等值比较
* 冲突多的时候维护代价高、访问也会很慢

#### 2.3 其他索引
* 空间数据索引：R树实现多维上的划分，类似B树
* 位图Bitmap索引：适合只有几个固定值的列，适合静态数据
* 聚簇Clustered索引：InnoDB对主键建立聚簇索引
* 反向键索引：索引叶块成为热点块（如批量插入数据），只能使用等值比较
* 函数索引：对指定函数建立索引，其他无效，等式匹配时才会生效

#### 2.4 不使用索引的情况
* 谓词中没有使用索引的最前列
* 跳跃式索引
* 使用COUNT(\*)
* 对于一个有索引的列作出函数查询
* 隐形函数查询
* 索引会更慢
* 没有正确的统计信息，造成CBO无法做出正确的选择

#### 2.5 注意点
判断索引适用性的依据：检索比率

如果系统为外键自动增加索引，常常会导致同一字段属于多个索引的情况。老版本中对各个字段分别构建索引是不好的措施，不能指望索引合并的策略。

使用复合键索引将选择性最高的列放到索引最前列，通常考虑全局基数和选择性。一个复合键索引能应付更多的状况，将范围检索放在最后，避免出现多个范围检索，使用IN代替范围检索。

系统生成键在插入并发性较高时会发生严重的资源竞争，使用反向键索引或哈希索引解决。

### 3 查询优化器
#### 3.1 绑定变量
替代变量为 &variable_para，绑定变量为 :bind_variable_para。绑定变量在library cache中共享游标，避免硬解析以及与之相关的额外开销。还可以减少锁的使用，避免锁的竞争。在非均匀分布的列上会产生错误的优化结果。

#### 3.2 优化器
有效范围：
* 借助数据库中找到的信息
* 进行数学意义上的等价转换
* 考虑整体响应时间
* 只能改善独立的查询

考虑因素：
* **所需访问的数据总量**：最重要的考虑因素
* 所需的查询条件：过滤条件的效率
  * 常量或常量表达式先行计算
  * 比较运算符的转换
  * 过滤条件的含义和好坏
* 结果集的大小：取决于表的大小和过滤条件的细节，尽量使其于响应时间成比例
* 涉及表的数量：不能连接太多表
* 修改数据用户的多少（并发控制）：注意数据块访问争用、阻塞、闩定、保证读取一致性

示例：
* 避免在最高层distinct：使用Exists存在性测试
* 非关联子查询：内层查询不再依赖外层查询，只需要执行一次
* 查询不存在的内容时使用左外连接
* 将聚合子查询转换为JOIN
* 非关联子查询变成内嵌视图

### 4 层次结构的存储
参考文章：[关系型数据库存储树形结构](http://1016990109.github.io/2018/06/05/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/)
#### 4.1 邻接模型
使用ID和parent_ID
* 增加/修改：直接操作parent_ID即可
* 删除：标记节点和子节点为删除状态
* 自顶向下查询
```sql
select *
from ...
start with id=1
connect by parent_ID = prior ID
缩排代码：lpad(description, length(description) + level)
lpad: 从左边对字符串使用指定字符进行填充
```
* 递归查询
```sql
1. 首先定义起始点：
select 1 as level, id, comment, parent_id
from table_name
where id=1 (能确定下起点的条件)
2. 然后定义每个子行与父节点之间关系：
select parent.level+1, child.id, child.comment, child.parent_id 
from recursive_query parent, table_name child
where parent.id = child.parent_id
最后合并：
with recursive_query(depth, id, comment, parent_id)
as (
#{1}
union all
#{2}
)
select *
from recursive_query
```

#### 物化路径模型
存储祖先链的方式实现树的存储：materialized_path
* 增加：获得父节点path再加上新节点的path
* 修改：更新该节点和所有后代的path
* 删除：
* 查询（缩排）：
```sql
select lpad(a.description, length(a.description)+mp_depth(...)) description, a.comment
from table_name a, table_name b
where a.path like b.path||'%' and ...(确定根节点语句)
order by a.path
其中mp_depth返回当前节点深度
```

#### 嵌套集合模型
left_num 和 right_num

### 5 数据表的物理实现
#### 5.1 IOT-索引组织表
IOT中的数据是按主键有序的存储在B树索引结构中。在IOT中每个叶结点即有每行的主键列值，又有那些非主键列值。IOT即是索引，又是实际的数据。
```sql
create table indexTable(
    ID varchar2(10),
    NAME varchar2(20),
    constraint pk_id primary key(ID))
organization index;
```
特别适用于订单表之类经常用between…and进行查询的表，经常更新的表不适合IOT

#### 5.2 分区/分区表
* 提高并发性和并行性
* 从而增强系统架构的可伸缩性
* 根据一个或多个字段中的值来定义分区，一个表最多有1024个分区

分区表的类型：
* 哈希分区
* 范围分区：分区表达式返回值必须是确定的整数
* 列表分区

使用范围：
* 数据量超大的情况下B树索引无法起到作用
* 分区充当索引的最初形态，以最小的代价定位数据所在区域
* 数据分布最好是均匀的

使用限制：
* NULL使得分区无效
* 分区列与索引列不匹配
* 选择分区的成本、打开锁住所有底层表的成本、维护分区的成本可能会很高

### 8 对冗余的控制（范式与反范式）
通过放宽对冗余的控制提升系统性能

以下情况考虑非规范化，加速关键部分：
* 结合1对1的关系
* 复制1:\*关系中非键列以减少连接
* 复制1:\*关系或\*:\*中FK列以减少JOIN
* 引入重复组
* 创建提取表：可以基于报表所需的表创建单个高度非规范化的提取表，并允许用户直接访问提取表而不是基表。
* 分区表：
	* 水平分区：在多个（较小的）表中分配记录
	* 垂直分区：在多个（较小的）表中分配列。PK重复以允许重建。
