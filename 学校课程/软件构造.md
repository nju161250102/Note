# 软件构造
参考教材：代码大全（第二版）

## Part 1 代码大全

### 1 欢迎进入软件构造的世界
#### 1.1 什么是软件构造技术
软件开发包括：问题定义、需求分析、实现计划、总体设计、详细设计、编码实现、系统集成、单元测试、系统测试、校正性的维护、功能强化。  
软件构造的主要活动是编码和调试，也涉及部分的详细设计、规划构建、单元测试、集成、集成测试等其他活动。  
测试和调试的区别在于：测试是为了发现错误，调试是为了改正错误。

#### 1.2 软件构造为何如此重要
软件构造的重要性：  
* 构造活动是软件开发的重要组成部分
* 构造活动是软件开发中的核心活动
* 把主要精力集中于构造活动，可以极大地提高程序员的生产效率
* 创建活动的产品，源代码，往往是软件的唯一精确描述
* 构造活动是唯一一项必不可少的工作  

### 2 用隐喻来更充分地理解软件开发
#### 2.1 隐喻的重要性
隐喻可以帮助开发人员借助类比的力量加深对编程的理解。  

#### 2.3 常见的软件隐喻
* 写代码 Writing Code：  
暗示着开发过程是一种代价高昂的试错过程，而非仔细的规划和设计。  
* 培植系统 Growing a System
* 系统生长 System Accretion： 
暗示以增量的方法进行设计、编译和测试。
* 建造软件 Building Software：  
暗示开发中存在诸多阶段，如计划、准备和执行等，根据所建造软件的不同，这些阶段的种类和程度可能会发生变化。  
* 智慧工具箱 The Intellectual Toolbox
* 复合隐喻 Combing Metaphors

### 3 三思而后行：前期准备
#### 3.1 前期准备的重要性
在开始实现一个系统之前，必须清楚这个系统应该做什么以及如何做到这些。   
* 管理角度：做好计划意味着可以确定项目所需的时间、人数和计算机台数
* 技术角度：做好计划意味着可以明确你要构造的到底是什么
* 逻辑角度：准备工作的时间“物超所值”
* 类比角度：在着手构造一座大厦之前对设计图纸的审核工作是必不可少的。针对构造的每一阶段，清楚最关键的需求和架构要素
* 数据角度：发现错误的时间要尽可能接近引入该错误的时间（在构造过程中进行非必要改动的代价是高昂的）

#### 3.2 辨明所从事的软件类型
最常见的三种类型：  
* 商业系统（Business Systems）
* 使命攸关的系统（Mission-Critical Systems）
* 性命攸关的系统（Embedded Life-Critical Systems）  

不同类型的项目倾向于不同的开发方式  
* 商业系统倾向于使用高度迭代的开发方式
* 性命攸关的系统往往要求更加序列式的方法  

在序列式开发法和迭代式开发法之间做出选择：  
序列式开发使用瀑布式模型进行开发，适用于需求相对稳定的情况。  
迭代式开发指整个开发工作被组织为一系列的迭代过程。每一次迭代都包括了需求分析、设计、实现与测试。适用于需求容易变化的情况

倾向于序列式开发的情况：  
* 需求相当稳定
* 设计相对简单、容易
* 后期改变需求、设计和编码的代价非常高  

倾向于迭代式开发的情况：  
* 需求相对不稳定，或需要不断加深理解
* 设计复杂，具有挑战性
* 后期改变需求、设计和编码的代价比较低

#### 3.3 问题定义的先决条件
问题定义：项目要解决的问题是什么。 也称为产品设想（Product Vision）任务陈述（Mission Statement）产品定义（Product Definition）  
明确的问题定义是第一项先决条件：在开始软件构造之前首先要check是否已经对系统要解决的问题做出了明确的陈述。  
关于问题定义的注意点：  
* 问题定义并不涉及任何可能的解决方案
* 问题定义应该用客户容易理解的语言编写
* 问题定义应该从客户的角度编写  

#### 3.4 需求的先决条件
需求定义详细规定了软件系统应该做什么。也称为软件需求（Software Requirement）功能规约（Function Specification）  
明确的需求定义是另一项先决条件：在开始软件构造之前要check是否已经充分详尽地描述了系统所要做的事情。  
需求变更的主要来源是开发过程帮助客户更好的理解自己的需求。认识到需求变更的必要性，并采取措施使得变更的负面影响最小化  

#### 核对表：需求
针对功能需求（规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求）：  
* 是否详细定义了系统的全部输入  
  输入的来源、精度、取值范围、出现频率等。
* 是否详细定义了系统的全部输出  
  输入的目的地、精度、取值范围、出现频率等。
* 是否详细定义了所有输出格式  
  Web页面、报表、磁盘文件
* 是否详细定义了所有硬件及软件的外部接口  
  外部接口指该软件实体与外部硬件对接以及其它软件交互部分的接口
* 是否详细定义了全部外部通信接口  
  握手协议、纠错协议、通信协议等
* 是否列出了用户想要做的全部事情  
* 是否详细定义了每个任务所用及得到的数据  

针对非功能需求（指软件产品在功能以外的服务质量方面的需求）：  
* 是否为必要操作定义了期望的相应时间  
  在实时系统中是响应时间必要的  
* 是否详细定义了其它与计时有关的考虑  
  处理时间、数据传输率、系统吞吐量  
* 是否详细定义了安全级别  
* 是否详细定义了可靠性  
  包括软件失灵的后果、需要保护的重要信息、错误检测以及恢复策略  
* 是否详细定义了内存、硬盘的使用要求
* 是否详细定义了系统的可维护性  
  功能的变更、操作环境的变更和接口的变更  
* 是否包括对“成功”、“失败”的定义  

针对需求的质量：
* 需求定义自身所表现出来的质量
* 需求的清晰性、一致性、可测试性等  

针对需求的完备性：
* 是否可以覆盖问题定义所描述的信息
* 是否不包含不能实现的需求

#### 3.5 架构的先决条件
软件架构（Software Architecture）是软件设计的高层部分，用于支撑更加细节的设计的框架。也称为系统架构（System Architecture）顶层设计（Top-level Design）  
明确的架构设计也是构造的先决条件：在开始软件构造之前要check是否已经在整个系统范围内定义了相应的框架结构。  
软件架构是构建计算机软件实践的基础：  
* 软件架构定义了一张用于描述整个系统各个方面的草图
* 是一个软件系统从整体到部分的最高层次的划分
* 建造一个系统所作出的最高层次的、以后难以更改的，商业的和技术的决定  
软件架构的两个要素是元件划分和设计决定。  

### 4 关键的构造决策
#### 4.1 选择编程语言
编程语言影响程序员的思维  
#### 4.2 编程约定
底层具有相同的编程风格  
#### 4.3 你在技术浪潮中的位置  
深入一种语言去编程  
#### 4.4 选择主要的构建实践方法
编码、团队工作、质量保证、工具  

### 5 软件构建中的设计
#### 5.1 设计中的挑战  
* 设计是险恶的（wicked）问题，只有通过解决或部分解决才能明确
* 设计是了无章法的过程
* 设计需要取舍和调整顺序
* 设计会受到很多限制
* 设计是不确定的
* 设计是一个启发式过程
* 设计是自然而然形成的  

#### 5.2 关键的设计概念
**软件的首要技术使命是管理复杂度**  

两种方法：  
* 把任何人在同一时间需要处理的本质(essential)复杂度的量减到最少；
* 不让偶然(accidental)的复杂度无谓地快速增长  

理想的设计特征：  
* 最小复杂度：简单、容易理解
* 易于维护
* 松散耦合
* 可扩展性
* 可重用性
* 高扇入、低扇出
* 可移植性
* 精简性：没有多余代码
* 层次性：能在任意层次上观察系统
* 标准技术  

设计的层次：  
* 软件系统
* 分解为子系统或包  
> 常见的子系统：业务h规则、用户界面、数据库访问、对系统的依赖性  
* 分解为类（定义与系统其余部分打交道的细节）
* 分解为子程序（细化出类的私有子程序）
* 子程序内部（布置详细功能）

#### 5.3 设计构造块——启发式方法
找出现实中的对象：  
* 辨识对象及其属性（method & data）
* 确定可对各个对象进行的操作
* 确定对象能对其他对象进行的操作
* 区分哪些部分对其他对象可见（public or private）
* 确定公开接口（public interface）  

形成一致的抽象：关注一组派生类的共同特性，忽略无关的细节。  
封装实现细节：除抽象之外，不能看到其他细节。  
信息隐藏：隐藏复杂度和隐藏变化源。  
找出容易变化的区域（并进行分离和隔离）  
保持松散耦合：简单数据参数耦合、简单对象耦合、对象参数耦合、危险的语义耦合。  
> 耦合度表示类之间或子程序之间关系的紧密程度  

### 6 可以工作的类
类是一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责，也可以是一组子程序集合，提供一组内聚的服务。  
#### 6.1 类的基础：抽象数据类型(ADT)
ADT是指一组数据以及对这些数据所进行的操作的集合。抽象数据类型可以像现实世界一样操作实体，而不必关注底层实现细节。  
使用ADT的益处：  
* 可以隐藏实现细节
* 改动不会影响整个程序
* 让接口提供更多的信息
* 更容易提升性能
* 让子程序的正确性显而易见
* 程序更具自我说明性
* 无须在程序内到处传递数据
* 像在现实世界中那样操作实体，而不用在底层实现上操作它  

ADT和类：ADT构成了类概念的基础。类还涉及继承和多态两个额外的概念。  

#### 6.2 良好的类接口
好的抽象：类接口提供一组明显相关的子程序   
* 尽量展现一致的抽象层次（仅实现一个ADT）
* 理解类接口应该捕获的抽象到底是哪一个
* 提供成对的服务
* 把不相关的信息转移到其他类
* 让接口可编程，而不是表达语义
* 不要添加与接口抽象不一致的公用成员
* 同时考虑抽象性和内聚性  
  

好的封装：不要暴露自身数据和实现细节  
* 尽可能限制类和成员的可访问性（public...修饰符）
* 不要公开暴露成员数据（Getter/Setter）
* 避免把私有的实现细节放入类的接口中（使用指针指向不确定的实现）
* 不要对类的使用者做出任何假设（不能有隐含的契约）
* 避免使用友元类（C++，friend）
* 不要因为一个子程序只使用公用子程序，就把它归入公开接口
* 让阅读代码比编写代码更方便
* 警惕从语义上破坏封装性！（针对接口编程！）
* 留意过于紧密的耦合关系  

#### 6.3 有关设计和实现的问题
包含（has a ...）:    
* 实现“有一个/has a”的关系
* 警惕超过7个数据成员的类

继承（is a ...）:  
* 使用继承时要进行详细说明
* 遵循Liskov替换原则  
> “派生类能通过基类接口被使用，且使用者无需了解两者之间的差异”  
> 基类中定义的所有子程序，用在它的任何一个派生类中含义都应该是相同的  
* 确保只继承需要继承的部分
* 不要“覆盖”一个不可覆盖的成员函数（注意函数重名问题）
* 把共用内容放到继承树中尽可能高的位置
* 让所有数据都是private（对需访问属性提供protected访问器）
* 尽量使用多态，避免大量类型检查（case语句大量出现可考虑使用继承）

成员函数和数据成员：  
* 让类中子程序的数量尽可能少
* 禁止隐式产生不需要的成员函数和运算符（定义为private）
* 减小类和类之间相互合作的范围
* 减少对其他类的子程序的间接调用  
> Demeter法则
> 在面向对象的方法中，一个方法“M”和一个对象“O”只可以调用以下几种对象的方法：
> 1. O自己
> 2. M的参数
> 3. 在M中创建的对象
> 4. O的直接组件对象

避免：万能类、无关紧要的类、只用动词命名的类

### 15 使用条件语句
控制其他语句是否执行
#### 15.1 if 语句
遵循的指导原则：  
* 首先写正常代码路径，再处理不常见情况
* 正常情况处理放在if后面而不是else后面
* 确保对于等量的分支是正确（边界情况）
* if子句后面跟随一个有意义的语句，而不是留空
* 检查else

调用布尔函数简化复杂的检测，封装判断过程，注意短路求值（节约计算成本，避免出错）

避免深层嵌套：
* 重复判断一部分条件
* 转化为if-then-else
* 转化为case
* 把代码提取为单独的子程序
* 使用对象和多态划分

#### 15.2 case语句
* 简化每种情况对应的操作
* 不要刻意制造一个变量
* deafult用于检查真正的默认情况
* default用于检查错误
* 记住使用break

### 16 控制循环
反复执行一段代码
#### 16.1 选择循环的种类
* 计数循环
* 连续求值的循环
* 无限循环
* 迭代器循环

根据灵活度与检查位置分类

使用带退出循环：
* 出现半循环的代码
* 退出条件放在一处
* 注释阐明操作意图

#### 16.2 循环控制
理念：使循环尽量模块化

如何进入循环：
* 从一个位置进入循环
* 初始化代码放在循环前面
* while(true)表示无限循环
* 多使用for
* while适用时不要使用for循环

处理好循环体：
* 避免空循环
* 控制循环变量的操作放在开头或者末尾

退出循环体：
* 确认循环能够终止
* 使终止条件明显
* 不要为了终止循环改动for循环的下标
* 避免出现依赖循环下标最终取值的代码

### 17 不常见的控制结构
#### 17.1 子程序中的多处返回
* 如果能增强可读性，就使用return
* 使用防卫语句简化复杂的错误处理

#### 17.2 递归
问题分成小部分，调用自己分别解决每个部分。

技巧：
* 确认递归能够终止
* 使用安全计数器防止无穷递归
* 避免循环递归
* 留心栈空间

#### 17.3 goto
不能随意使用

### 18 表驱动法
从表里面查找信息而不使用逻辑语句，使用于复杂的逻辑，使其从代码中独立出来。

问题：表里存放什么信息；如何快速从表中查询条目（直接、索引、阶梯）

## Part 2 面向对象软件构造

### 面向对象设计原则
[![面向对象设计原则简介](https://s1.ax1x.com/2018/12/25/Fc3lIP.md.png)](https://imgchr.com/i/Fc3lIP)

#### 单一职责原则
> 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中
>
> * 类的职责包括数据职责（属性）和行为职责（方法）

一个类（或者大到模块，小到方法）承担的职责越多，它被
复用的可能性越小。

#### 开闭原则
> 一个软件实体应当对扩展开放，对修改关闭。
>
> * 软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类

抽象化是开闭原则的关键。对可变性封装——找到系统的可变因素并将其封装起来。

#### 里氏代换原则 LSP
> 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型S是类型T的子类型。
> 或者：所有引用基类（父类）的地方必须能透明地使用其子类的对象

通俗表述：在软件中如果能够使用基类对象，那么一定能够使用它的子类对象。因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

#### 依赖倒转原则 DIP
> 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
> 或者：针对接口编程，而不是针对实现编程

代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。或者是在代码中使用抽象类，而将具体类放在配置文件中。

依赖注入：
* 构造注入：通过构造函数注入实例变量
* 设值注入：通过Setter方法注入实例变量
* 接口注入：通过接口方法注入实例变量

#### 接口隔离原则 ISP
> 客户端不应该依赖那些它不需要的接口

如果一个接口太大，需要将它分成一些更小的接口。一个接口就只代表一个角色，一个接口仅仅提供客户端需要的行为。拆分接口时满足单一职责原则，为不同的客户端提供宽窄不同的接口。

#### 合成复用原则 CRP
> 尽量使用对象组合，而不是继承来达到复用的目的

在一个新的对象里通过关联关系（组合关系和聚合关系）来使用一些已有的对象，新对象通过委派调用已有对象的方法达到复用其已有功能的目的，从而实现少用继承的目的。组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。

#### 迪米特法则
> 不要和“陌生人”说话，只和你的直接朋友通信。

一个软件实体应当尽可能少的与其他实体发生相互作用，这样修改模块时会尽量少地影响其他模块，扩展会相对容易。对象可以使用的对象包括：
* 当前对象本身
* 以参数形式传入当前对象方法中的对象
* 自己的成员对象
* 自己创建的对象

在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过第三者转发。但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协调。广义的迪米特法则主要是对信息隐藏的控制。

#### 总结
* 单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。
* 开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。
* 里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。
* 依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。
* 接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。
* 合成复用原则要求复用时尽量使用对象组合，而不使用继承。
* 迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。