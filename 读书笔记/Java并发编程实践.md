# Java 并发编程实践

### Chapter 2 线程安全

状态：对外部可见行为产生影响的数据

共享：一个变量可以被多个线程访问

线程安全：管理对状态的访问，取决于多个线程如何使用对象

线程安全类不代表整个程序都是线程安全的。

#### 2.1 线程安全性

多个线程访问时，不需要额外的同步或者协调代码，类仍然可以持续进行正确的行为。即：线程安全类封装了任何必要的同步。

无状态对象永远是线程安全的。

#### 2.2 原子性

竞争条件：计算的正确性依赖于运行时的执行顺序

- 检查再运行：检查到运行的时间内原来的状态可能已经改变
- 惰性初始化（懒加载）：最终返回不同的对象

复合操作：确保操作要么没有执行，要么全部执行完

#### 2.3 锁

synchronized：锁对象的引用，保护的代码块。synchronized方法的锁对象是方法所在对象本身。

- 内部锁：每个Java对象都能隐式扮演一个锁的角色
- 互斥锁：最多只有一个线程才能拥有锁，其他线程必须在释放前一直等待下去
- 重进入：基于线程而不是基于调用，因此子类覆盖的方法也能进入父类的锁

#### 2.4 用锁保护状态

- 每个可共享的可变变量需要由一个唯一确定的锁保护（多个线程访问可变数据）
- 每个涉及多个变量的不变约束，需要由同一个锁保护所有的变量（多个操作的合并）

#### 2.5 活跃度与性能

尽量从 synchronized 中分离耗时且不影响共享的操作

### Chapter 3 共享对象

内存可见性：一个线程修改变量后，其他线程能够真正看到改变

#### 3.1 可见性

重排序：单个线程中，如果重排序不对结果产生影响，那么就不能保证其中的操作一定按照写的顺序执行。

过期数据：同时使用get方法可能会获得过期的数据

64位数据：读取非volatile的long或者double数据可能会出现不同值的高低64位

锁与可见性：相同的锁可以保证线程之间的可见性（读取正确的值）

volatile：不会被重排序，总能获取最新值，但是不能保证操作的原子性

#### 3.2 发布和逸出

错误做法：

- 间接发布其他对象

- 非私有方法中返回引用
- 内部类实例包含封装实例的引用

正确做法：使用私有的构造函数和一个公共的工厂方法注册监听器或者启动线程

#### 3.3 线程封闭

Swing的事件分发线程；JDBC连接池的管理模式

- Ad-hoc非正式线程限制：使用 volatile 关键字
- 栈限制：使用方法栈内部的变量
- ThreadLocal：返回当前执行线程通过set设置的最新值

#### 3.4 不可变性

永远是线程安全的，必须满足：

- 状态不能在创建后被修改
- 所有域都是 final 类型
- 被正确创建（没有this 逸出）

可以使用不可变的容器类来持有所有变量

#### 3.5 安全发布

不能简单地将对象的引用存储在公共变量中，可能会导致线程读取到过期值。

- 使用静态初始化
- 引用存储到 volatile 或 AtomicReference
- 存储到正确创建对象的 final 域中
- 存储到由锁保护的正确的域之中