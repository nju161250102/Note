# 企业应用架构模式

### 引言

架构：高层次的系统分解；系统中不易改变的决定

企业应用：持久化数据；大量数据；并发访问；用户界面；应用集成；不一致的概念；复杂的业务逻辑

模式：根据实际情况选择、更改、优化合适的模式

### 1 分层

优点：减少依赖；标准化工作；面向接口

缺点：级联修改；运行效率下降

难点：决定建立哪些层次，以及每一层的职责

#### 1.2 三个基本层次

* 表现层：提供服务，显示信息，处理用户请求
* 领域层：逻辑
* 数据源层：与数据库、消息系统、事务管理器通信

选择合适的分离方式：子程序、类、包

领域层和数据源层绝对不要依赖于表现层

#### 1.3 为各层选择运行环境

数据源层通常运行在服务器端，领域逻辑则可以一分为二（提取出独立的模块？）

### 2 组织领域逻辑

* 事务脚本：从表示层获得输入、校验和计算处理、存储数据或调用其他系统的操作、组织整理返回值、返回给表示层。因此可以想象成一个动作或者业务事务的脚本。
  * 优点：简单易理解；与简单数据源层很好地协作；易于设定事务边界
  * 缺点：增加复杂性；难以复用
* 领域模型：面向对象方法，由对象承担相应逻辑。
  * 缺点：使用上的复杂性和映射到数据库的复杂
* 表模块：与记录集一起工作，只有一个公共的实例。
  * 优点：容易发现和移除冗余代码
  * 缺点：无法应用面向对象的设计模式

#### 2.1 抉择

复杂的领域逻辑选择领域模型，拥有基于记录集的工具选择表模块，三种模式并不互相排斥。

#### 2.2 服务层

置于领域模型或者表模块之上，提供清晰的API（根据用例组织），放置事务与安全性控制功能

### 3 映射到关系数据库

#### 3.1 架构模式

* 行数据入口：为返回的每一行产生一个实例（面向对象的方式看待数据）
* 表数据入口：以记录集模拟数据库的表格式属性
* 数据映射器：处理数据库与领域模型之间所有的存取操作

#### 3.2 行为问题

保证使用的数据库状态的一致性（同步问题）

工作单元：跟踪所有从数据库中读取的对象和以任何形式修改过的对象，排列复杂的数据库交互

#### 3.3 读取数据

* 接口模式决定何处放置查找器
* 最好创建独立的查找器变量
* 查找器方法工作在数据库状态下

简单的性能优化经验：

* 尽量一次返回多行
* 尽可能避免使用Join

#### 3.4 结构映射模式

外键映射：一对多关系

关联表映射：多对多关系

单表继承：为所有类建立一个表（属性冗余），表过大

具体表继承：为每个具体类建立一个表（属性重复），难以更改

类表继承：需要多个连接操作载入对象，损失性能

### 4 Web表现层

模型—视图—控制器：

* 控制器处理请求消息
* 模型负责领域逻辑
* 视图基于模型创建应答消息

#### 4.1 视图模式

* 模板视图：在网页结构中编写表示层，嵌入标签甚至代码
* 转换视图：XSLT
* 两步视图：提取出公用的基本视图，再创建细化的视图

#### 4.2 输入控制器模式

为每一个页面准备一个输入控制器。两种职责：处理HTTP请求消息，根据消息决定下一步做什么。

### 5 并发

* 需要跨事务处理数据
* 应用服务器系统支持多线程

#### 5.1 并发问题

* 更新丢失
* 不一致读

#### 5.2 执行语境

* 请求：单个调用
* 会话：一系列用户认为有逻辑关联的请求
* 进程与线程：进程内存在多个线程，线程共享内存
* 事务：多个请求作为单个请求看待

#### 5.3 隔离与不变性

每一片数据只能被一个执行单元访问。找到各种创建隔离区的办法并保证每个隔离区内完成尽可能多的任务。

#### 5.4 乐观并发控制和悲观并发控制

乐观锁：冲突检测；悲观锁：冲突避免

* 避免不一致读：
  * 乐观锁：对数据进行版本标记
  * 悲观锁：读锁（共享锁）和写锁（排他锁）
* 死锁：死锁检测机制和超时控制机制

#### 5.5 事务

事务是一个有边界的工作序列，要么全部完成，要么什么都不做。

* 原子性：都完成或者都不完成
* 一致性：完成和开始后处于一致状态
* 隔离性：成功提交后对其他事务才是可见的
* 持久性：已提交事务的结果是永久的

隔离级别：

* 可串行化
* 可重复读：允许幻读
* 读已提交：允许不可重复读
* 读未提交：允许脏读

### 9 领域逻辑模式

#### 9.1 事务脚本

使用过程组织业务逻辑，每个过程来自表现层的单个请求，在过程中直接调用数据库。

简单、不适合复杂的业务逻辑。

#### 9.2 领域模型

领域模型合并了业务活动中的数据和业务过程中的行为，采用面向对象的方式建模，由此提高系统的可扩展性与复用性。领域模型与系统中其他层的依赖应达到最小。

领域模型能够解决很复杂的业务逻辑，但是到数据库的映射比较困难。简单模型采用活动记录，复杂模型采用数据映射器。

#### 9.3 表模块

以一个类对应数据库的一个表来组织领域逻辑，使用单一的类实例来进行各种操作。表模块用一个类直接表示表中所有数据及行为，先把数据库的所有行加载到表模块，之后处理所有业务都直接与表模块有关。

单表操作的简单业务逻辑比较方便，复杂业务逻辑需要辅助类完成。

### 10 数据源架构模式

#### 10.1 表数据入口

表数据入口包含用于访问单个表或者视图的所有SQL操作，其他代码调用它的方法来实现与数据库的交互。

- 特别适用于事务脚本，用于处理结果集的数据行
- 用于表模块，产生的数据集由表模块进行处理
- 不适用于领域模型，数据映射器更好地分离了领域模型与数据库

#### 10.2 行数据入口

行数据入口是单条记录相似的对象，自身拥有插入、更新、删除操作。查找操作在单独的一个类中完成。

行数据入口一般能实现从数据源类型到内存中类型的任意转换。行数据入口不存在任何领域逻辑，如果存在，则是活动记录。

- 事务脚本：分离数据库访问代码，被不同的事务脚本重用，可能带来重复的业务逻辑。
- 领域模型：数据映射器更加适合，不过可以配合使用
- 表模块：不考虑

#### 10.3 活动记录

包装数据库或者视图中的某一行，封装数据库访问，并增加了领域逻辑。

活动记录的本质是一个领域模型，数据结构应该完全和数据库结构相匹配。

- 事务脚本：减少事务脚本代码重复的痛苦。
- 领域模型：适用于不太复杂的领域逻辑，如CRRD等。仅当活动记录对象和数据库中表直接对应，才比较有效。如果业务逻辑复杂，就会想到使用对象的直接关系、集合和继承等。它们难以映射到活动记录。
- 表模块：不考虑

#### 10.4 数据映射器

将数据映射到对象的类数据。

通常和领域模式一起使用，此时数据库方案和对象模型可以彼此独立演变。对于简单的业务逻辑而言是没有必要的。

### 11 对象-关系行为模式

#### 11.1 工作单元

维护受业务事务影响的对象列表，并协调变化的写入和并发问题。

工作单元记录在业务事务过程中对数据库有影响的所有变化。

- 调用者注册：改变对象时手动注册到工作单元
- 对象注册：从数据库加载时对象是“干净的”，修改后是“脏”的
- 工作单元控制器：读操作时产生拷贝，提交时检查是否发生变化，适用于读操作远远多于写操作的情形

#### 11.2 标识映射

通过映射保存每个已经加载的对象，确保只加载一次。当访问对象时，通过映射来查找。

#### 11.3 延迟加载

- 延迟初始化：第一次使用时初始化
- 虚代理：从数据库中加载恰当的对象
- 值保持器：第一次访问时才从数据库中获取值
- 重影