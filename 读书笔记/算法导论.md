# 算法导论

## 15 动态规划
通过组合子问题的解来求解原问题，子问题之间会有重叠，动态规划将避免求解子问题时进行的重复计算。
* 刻画一个最优解的结构特征
* 递归地定义最优解的值
* 计算最优解的值
* 利用计算出的信息构造一个最优解

### 15.1 钢条切割
为了求解规模为n的原问题，先求解形式完全一样但是规模更小的子问题。

> 最优子结构：问题的最优解由相关子问题的最优解组合而成，并且这些子问题可以独立求解。

使用动态规划方法求解：付出额外的内存空间来节省计算时间。有以下两种等价的实现方法：
* 带备忘的自顶向下法：先检查值是否已知，否则计算并保存值
* 自底向上法：从小规模问题向上构建

> 子问题图：顶点对应唯一的子问题，边表示子问题之间的依赖关系。

### 15.2 矩阵链乘法
1. 最优化括号化方案的结构特征：可以选择划分点确保不遗漏最优解。
2. 一个递归求解方案：给出最优解的递归表达式，使用额外的数据结构保存划分方案
3. 计算最优代价：长度为2...n链的最小计算代价
4. 构造最优解：类似方法递归求出更早的子问题的最优解

### 15.3 动态规划原理
* 最优子结构：一个问题的最优解包含子问题的最优解
  * 证明得到最优解的第一步是做出一个选择
  * 假定第一步选择中知道何种选择能得到最优解
  * 确定选择会产生哪些子问题以及最好地刻画子问题空间
  * 证明每个子问题的解是本身的最优解的一部分
* 子问题重叠：递归算法将反复求解相同的子问题

### 15.4 最长公共子序列
重点在于递归公式的寻找

### 15.5 最优二叉搜索树

## 16 贪心算法
贪心算法总是做出局部最优的选择，并且希望可以由此得到全局最优解。

### 16.1 活动选择问题
首先可以验证活动选择问题具有最优子结构性质，可以设计使用动态规划的方法求解。然后证明贪心选择（总是选择结束时间最早的活动）总是最优解的一部分。之后可以使用迭代来改写递归算法。

### 16.2 贪心算法原理
1. 将最优化问题转化为：做出一次选择后只剩下一个子问题需要求解。
2. 证明做出贪心选择后，原问题总是存在最优解，即贪心选择是安全的。
3. 证明做出贪心选择后，剩余的子问题满足：最优解与子问题的最优解组合可以得到原问题的最优解。

关键要素：
* 贪心选择性质：选择时不必依赖子问题的解，所以通常是自顶向下的。
* 最优子结构

### 16.3 Huffman编码

### 16.4 拟阵和贪心算法

## 22 基本的图算法
图G=(V 顶点, E 边)
### 22.1 图的表示
|比较|邻接链表|邻接矩阵|
|:--:|:--:|:--:|
|空间复杂度|O(V+E)|O(V^2)|
|存在边|O(V) or O(W)|O(1)|
|相邻顶点|O(V)|O(V)|
|适用图|稀疏图|稠密图|
|权重存放|结点|对应记录|

邻接矩阵用于快速判断是否有边相连，对于不存在的边通常存放0或∞

### 22.2 广度优先搜素
给定图G=(V, E)和源结点s，得到每个可达结点的距离和广度优先搜索树，时间复杂度为O(V+E)

#### 伪代码
```python
# 初始化
for each vertex u in G.V-s:
	u.color = WHITE
	u.d = ∞
	u.π = None
s.color = GRAY
s.d = 0
s.π = None
# 使用FIFO队列
Q = Queue()
Q.enqueue(s)
while not Q.empty():
	u = Q.dequeue()
	# 对于v的每个邻接结点
	for each v in G.Adj[u]:
		if v.color == WHITE:
			v.color = GRAY
			v.d = u.d + 1
			v.π = u
			Q.enqueue(v)
```

#### 广度优先搜索树
由前驱结点π得到的前驱子图

### 22.3 深度优先搜索
给定图G=(V, E)，生成深度优先搜索森林和结点的时间戳（被发现的时间和完成扫描的时间）

#### 伪代码
```python
time = 0  # 记录时间
def DFS(G):
	for each vertex u in G.V:
		u.color = WHITE
		u.π = None
	for each vertex u in G.V:
		if u.color == WHITE:
			DFS_VISIT(G, u)

def DFS_VISIT(G, u):
	time = time + 1
	u.d = time  # 记录被发现时间
	u.color = GRAY
	for each v in G.Adj[u]:
		if v.color == WHITE:
			v.π = u
			DFS_VISIT(G, v)
	u.color = BLACK
	time = time + 1
	u.f = time  # 记录搜索结束时间
```

#### 括号化定理
考察两个结点的发现时间与结束时间的区间 [u.d, u.f] 与 [v.d, v.f]
* 如果两者没有交集, 则两个结点在两个不同的子树上
* 如果 u 的区间包含在 v 的区间, 则 u 是v 的后代

#### 深度优先搜索森林
由前驱结点生成的前驱子图是由多棵树构成的森林。

#### 边的分类
树边、后向边、前向边、横向边
* 第一次搜索到边(u, v)时，v的颜色：白色-树边，灰色-后向边，黑色-前向边或横向边
* 对无向图进行深度优先搜索时，每一条边都是树边或后向边

### 22.4 拓扑排序
对于有向无环图，利用 DFS, 结点的完成时间的逆序就是拓扑排序。同一个图可能有不同的拓扑排序。

### 22.5 强连通分量SCC
对集合中任一对结点(u, v)，u到v和v到u的路径同时存在。

在图G和G的转置上分别运行DFS，其中在G的转置上按G结点的拓扑排序进行DFS_VISIT，得到的DFS 森林中每个树就是一个强连通分量。
