# 高性能MySQL

## 5 创建高性能的索引
索引（key）是存储引擎用于快速找到记录的一种数据结构。索引优化是对查询性能优化最有效的手段。  

### 5.1 索引基础
* 存储引擎根据匹配的索引记录找到对应的数据行。
* 如果索引包含多个列，列的顺序也十分重要。
#### 5.1.1 索引的类型
**B-Tree索引**  
所有的值都是按顺序存储的，每一个叶子页到根的距离相同。存储引擎不再需要全表扫描来获取数据，而是从根节点开始搜索，最终找到对应的值或者记录不存在。  
根节点和叶子节点之间有很多层节点页，树的深度和表的大小直接相关。  
节点是有序的，因此可以使用B-Tree索引的查询类型：  
* 全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值
* 精确匹配某一列+范围匹配另一列
* 只访问索引的查询  

**哈希索引**  
基于哈希表实现，精确匹配索引所有列的查询才有效。不同键值的行计算出来的哈希码不一样。如果多个哈希值相同，索引会以链表的方式存在同一个哈希条目之中。  
哈希索引的结构紧凑，但也有自身的限制：  
* 只包含哈希值和行指针，不存储字段值，不能使用索引的值避免读取行。
* 不按索引值顺序存储，因此无法用于排序。
* 不支持部分索引列匹配查找
* 只支持等值比较查找，不支持任何范围查找  

创建自定义哈希索引： 
* 只需要很小的索引就可以为超长的Key创建索引
* WHERE子句中手动指定使用哈希函数(CRC32)
* 使用触发器维护哈希索引
* SHA1和MD5浪费空间，可以使用其返回值的一部分作为自定义的哈希函数  

适用范围：  
* 特定场合，效果拔群
* 数据仓库的星型schema
* InnoDB的自适应哈希索引

### 5.2 索引的优点
* 减少服务器需要扫描的数据量
* 帮助服务器避免排序和临时表
* 将随机I/O变为顺序I/O

### 5.3 高性能索引策略
针对特定案例或特定行为优化
#### 5.3.1 独立的列
索引列不能是表达式的一部分，也不能是函数的参数。因此应当简化WHERE条件，将索引列单独放在比较符号的一侧。

#### 5.3.2 前缀索引和索引选择性
索引开始的部分字符，节约索引空间：选择足够长的前缀以保证较高的选择性，考虑最坏情况下的选择性。缺点是无法使用前缀索引做ORDER  BY和GROUP BY，也无法做覆盖扫描。  

#### 5.3.3 多列索引
索引合并策略：  
* 对单列索引进行扫描，并将结果进行合并
* 联合操作耗费大量计算资源并且不会被计算到查询成本之中  

索引合并操作意味着需要检查查询和表的结构，通过optimizer_switch关闭索引合并功能，IGNORE_INDEX提示优化器忽略某些索引。  

#### 5.3.4 选择合适的索引列顺序
不需要考虑排序和分组时，将选择性最高的列放到索引最前面。  
> 查询不仅依赖于所有索引列的选择性，也和查询条件值的分布有关。
> 案例：应用程序内部区分特殊用户和组并采用不同的查询方式。

#### 5.3.5 聚簇索引
