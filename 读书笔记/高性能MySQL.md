# 高性能MySQL

## 4 Schema与数据类型优化
### 4.1 选择优化的数据类型
以下几个简单的原则有助于做出更好的选择：  
* 更小的通常更好（占用更少的磁盘和CPU）
* 简单就好：使用简单的数据类型，整型而不是字符串
* 尽量避免NULL：NULL更难以优化

#### 4.1.1 整数类型
TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT分别使用8, 16, 24, 32, 64位存储空间。此外可以选择UNSIGNED属性增大正数的存储范围。INT()指定宽度不会限制合法范围，只规定交互工具的显示个数。

#### 4.1.2 实数类型
FLOAT和DOUBLE支持使用标准浮点运算进行近似计算。DECIMAL用于存储精确的小数，需要额外的空间和计算开销。如果数据量比较大，根据位数乘上相应倍数后用BIGINT存储。

#### 4.1.3 字符串类型
**VARCHAR**  
可变长字符串，仅使用必要的空间，UPDATE时可能需要额外的工作。在下列情况使用VARCHAR：最大长度远大于平均长度，列更新较少。末尾空格保留。  
**CHAR**  
末尾空格不保留。适用于定长的值、经常变更的数据、非常短的列（如Y/N）。
> 慷慨时不明智的，最好的策略是只分配真正需要的空间。  

**BLOB和TEXT**  
作为独立的对象处理，太大时会使用外部存储区域来进行存储。BLOB存储二进制数据，没有字符集或排序规则（TEXT有）。排序时只对前面一小部分字符排序，也不能将全部长度的字符串用于索引。  
**使用枚举代替字符串类型**  
保存一个数字-字符串映射关系的查找表。枚举字段的排序是按照存储的整数进行的（使用FIELD指定排序顺序）。添加或者删除字符串必须ALTER TABLE。  

#### 4.1.4 时间和日期类型
**DATETIME**  
大范围，精度为秒，8字节存储  
**TIMESTAMP**  
1970到2038年，精度为秒，4字节存储，支持时区  

#### 4.1.5 位数据类型
BIT：当作字符串类型，不一定节约空间，谨慎使用。  
SET：多组True/False，以打包的位的集合表示。难以更改列定义。  
在整数列上按位操作，查询语句难写且难以理解。

#### 4.1.6 选择标识符
* 整数类型通常是最好的选择，速度快且可以自增。
* EMUM和SET通常是糟糕的选择，适用于某些固定信息的存储。
* 避免使用字符串类型作为标识符，因为很消耗空间。随机的字符串会使插入和查询变得很慢。

#### 4.1.7 特殊类型数据
ipv4地址——应当使用无符号整数存储。  

### 4.2 MySQL schema设计中的陷阱
* 太多的列
* 太多的关联
* 全能的枚举
* 变相的枚举
* NULL**有时**可以使用一个特殊值替代

### 4.3 范式与反范式
#### 4.3.1 范式的优点和缺点
* 更新操作更快
* 修改较少的数据
* 更少使用DISTINCT或GROUP BY语句  
缺点：需要关联操作

#### 4.3.2 反范式的优点和缺点
数据比内存大时比关联快得多。

#### 4.3.3 混用范式与反范式
复制、缓存


## 5 创建高性能的索引
索引（key）是存储引擎用于快速找到记录的一种数据结构。索引优化是对查询性能优化最有效的手段。  

### 5.1 索引基础
* 存储引擎根据匹配的索引记录找到对应的数据行。
* 如果索引包含多个列，列的顺序也十分重要。
#### 5.1.1 索引的类型
**B-Tree索引**  
所有的值都是按顺序存储的，每一个叶子页到根的距离相同。存储引擎不再需要全表扫描来获取数据，而是从根节点开始搜索，最终找到对应的值或者记录不存在。  
根节点和叶子节点之间有很多层节点页，树的深度和表的大小直接相关。  
节点是有序的，因此可以使用B-Tree索引的查询类型：  
* 全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值
* 精确匹配某一列+范围匹配另一列
* 只访问索引的查询  

**哈希索引**  
基于哈希表实现，精确匹配索引所有列的查询才有效。不同键值的行计算出来的哈希码不一样。如果多个哈希值相同，索引会以链表的方式存在同一个哈希条目之中。  
哈希索引的结构紧凑，但也有自身的限制：  
* 只包含哈希值和行指针，不存储字段值，不能使用索引的值避免读取行。
* 不按索引值顺序存储，因此无法用于排序。
* 不支持部分索引列匹配查找
* 只支持等值比较查找，不支持任何范围查找  

创建自定义哈希索引： 
* 只需要很小的索引就可以为超长的Key创建索引
* WHERE子句中手动指定使用哈希函数(CRC32)
* 使用触发器维护哈希索引
* SHA1和MD5浪费空间，可以使用其返回值的一部分作为自定义的哈希函数  

适用范围：  
* 特定场合，效果拔群
* 数据仓库的星型schema
* InnoDB的自适应哈希索引

### 5.2 索引的优点
* 减少服务器需要扫描的数据量
* 帮助服务器避免排序和临时表
* 将随机I/O变为顺序I/O

### 5.3 高性能索引策略
针对特定案例或特定行为优化
#### 5.3.1 独立的列
索引列不能是表达式的一部分，也不能是函数的参数。因此应当简化WHERE条件，将索引列单独放在比较符号的一侧。

#### 5.3.2 前缀索引和索引选择性
索引开始的部分字符，节约索引空间：选择足够长的前缀以保证较高的选择性，考虑最坏情况下的选择性。缺点是无法使用前缀索引做ORDER  BY和GROUP BY，也无法做覆盖扫描。  

#### 5.3.3 多列索引
索引合并策略：  
* 对单列索引进行扫描，并将结果进行合并
* 联合操作耗费大量计算资源并且不会被计算到查询成本之中  

索引合并操作意味着需要检查查询和表的结构，通过optimizer_switch关闭索引合并功能，IGNORE_INDEX提示优化器忽略某些索引。  

#### 5.3.4 选择合适的索引列顺序
不需要考虑排序和分组时，将选择性最高的列放到索引最前面。  
> 查询不仅依赖于所有索引列的选择性，也和查询条件值的分布有关。
> 案例：应用程序内部区分特殊用户和组并采用不同的查询方式。

#### 5.3.5 聚簇索引


## 6 查询性能优化
### 6.1 为什么查询速度会变慢
优化查询 = 优化子任务，了解的查询的生命周期：客户端，到服务器，解析，生成执行计划，执行，返回结果。

### 6.2 慢查询基础：优化数据访问
1. 确认应用程序是否检索大量超过需要的数据（太多的行或列）  
2. 确认MySQL服务器层是否分析大量的数据行

#### 6.2.1 是否向数据库请求了不需要的数据
* 查询不需要的记录：使用LIMIT子句限制，而不是查出N行后关闭结果集
* 多表关联时返回全部列：只取需要的列
* 总是取出全部列：避免使用SELECT \*
* 重复查询相同的数据

#### 6.2.2 MySQL是否在扫描额外的记录
* 响应时间
* 扫描的行数
* 返回的行数

### 6.3 重构查询的方式
#### 6.3.1 一个复杂查询还是单个简单查询
有时候将大查询分解为多个小查询是很有必要的

#### 6.3.2 切分查询
分而治之，每次只返回一小部分的查询结果

#### 6.3.3 分解关键查询
对每个表进行一次单表查询，然后在应用程序中进行关联

### 6.4 查询执行的基础
#### 6.4.3 查询优化处理
MySQL能够处理的优化类型：  
* 重新定义关联表的顺序
* 将外连接转化为内连接
* 使用等价变换规则
* 优化COUNT、MIN、MAX
* 预估并转化为常数表达式
* 覆盖索引扫描
* 子查询优化
* 提前终止查询
* 等值传播
* 列表IN()的比较

## 7 MySQL高级特性
### 7.1 分区表
PARTITION BY定义每个分区存放的数据，查询就无须扫描所有分区，批量删除也会很有帮助。

使用场景：  
* 表非常大，只有部分热点数据
* 分区表的数据更容易伟华
* 高效利用多个物理设备
* 避免特殊的性能瓶颈
* 备份和恢复独立的分区

#### 7.1.1 分区表原理
先确定属于哪个分区，再将记录写入对应的底层分区表。  
每个操作会先打开并锁住所有的底层表，处理过程中不一定是锁住全表的。

#### 7.1.2 分区表的类型
根据范围进行分区，分区表达式可以是列或者包含列的表达式，要求返回一个确定的整数。  
此外还支持键值、模函数、哈希和列表分区

#### 7.1.3 如何使用分区表
数据量超大的时候，B树索引将不再起作用，分区作为一种更粗粒度但是消耗更少的方式进行数据检索。全量扫描数据，不要任何索引；索引数据，并分离热点。

#### 7.1.4 什么情况下会出问题
* NULL值使得分区过滤无效
* 分区列和索引列不匹配：导致查询无法进行分区过滤
* 选择分区的成本很高：尤其是按行写入大量数据的范围分区表
* 打开并锁住所有底层表的成本可能很高
* 维护分区的成本可能很高

#### 7.1.5 查询优化
在WHERE条件中带上分区列，即使看似多余，用于过滤无用的分区。使用EXPLAIN PARTITION可以观察是否执行了分区过滤。创建分区时可以使用表达式，查询时只能根据列来过滤。

#### 7.1.6 合并表
早期简单的分区实现，被淘汰的技术。

### 7.2 视图
视图本身是一个虚拟表，不存放任何数据。  
临时表模拟视图难以优化查询。MySQL 使用合并算法或者临时表算法处理视图。如果视图中包含GROUP BY、DISTINCT、任何聚合函数、UNION、子查询，都将使用临时表算法来实现视图。

#### 7.2.1 可更新视图
被更新的列来自同一个表，使用临时表算法的视图无法被更新，视图上无法建立触发器。

### 7.3 外键约束
约束检查的开销、需要额外的锁、使用触发器代替外键、在应用程序中实现约束。